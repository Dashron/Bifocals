<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Bifocals by Dashron</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Bifocals</h1>
        <p class="header">The view component of the roads framework</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/Dashron/Bifocals/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/Dashron/Bifocals/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/Dashron/Bifocals">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/Dashron">Dashron</a></p>


      </header>
      <section>
        <h1>Bifocals</h1>

<p>A node.js View library with support for asynchronous sub-views (aka partials), and interchangeable rendering systems.</p>

<h2>Table of Contents</h2>

<ul>
<li><a href="#installation">Installation</a></li>
<li>
<a href="#basic-use">Basic Use</a>

<ul>
<li><a href="#why-do-i-need-this-library">Why do I need this library?</a></li>
<li><a href="#important-notes">Important notes</a></li>
</ul>
</li>
<li><a href="#writing-your-own-renderer">Writing your own Renderer</a></li>
<li>
<a href="#function-reference">Function Reference</a>

<ul>
<li><a href="#module-reference">Module Reference</a></li>
<li><a href="#bifocals-reference">Bifocals Reference</a></li>
<li><a href="#renderer-reference">Renderer Reference</a></li>
</ul>
</li>
<li><a href="#coding-standards">Coding Standards</a></li>
<li><a href="#future-features">Future Features</a></li>
</ul>

<h3 id="installation">Installation:</h3>

<pre><code>npm install bifocals</code></pre>

<pre><code>var bifocals_module = require('bifocals');
var Bifocals = bifocals_module.Bifocals;
</code></pre>
<h3 id="basic-use">Basic Use:</h3>

<p>templates/index.html</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        {{{header}}}
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>templates/header.html</p>

<pre><code>&lt;header&gt;
    {{title}}
&lt;/header&gt;
</code></pre>

<p>server.js</p>

<pre><code>// Each content type needs to be registered to a Renderer.
// This tells bifocals to render all text/html views via handlebars.
bifocals_module.addRenderer('text/html', require('./renderers/handlebars_renderer'));

http_module.createServer(function (request, response) {
    // Create the parent:
    var view = new Bifocals();
    view.response = response;

    // Assign a content type.
    view.content_type = 'text/html';

    // Create the child:
    var child = view.child("header");
    child.set('title, "Hello World");
    child.render("templates/header.html");

    // Write the view to the response
    view.render("templates/index.html");
}
</code></pre>

<p>And you are done! When the client requests this page, it will receive the following html</p>

<pre><code>&lt;html&gt;
    &lt;head&gt;&lt;/head&gt;
    &lt;body&gt;
        &lt;header&gt;
            Hello World
        &lt;/header&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<h3 id="why-do-i-need-this-library">Why do I need this library?</h3>

<p>The previous example does not show the benefits of the library. The benefits come when performing asynchronous actions. It might be easier to explain with a more complex example.</p>

<pre><code>http_module.createServer(function (request, response) {
    // Create the parent:
    var view = new Bifocals();
    view.response = response;

    // Assign a content type.
    view.content_type = 'text/html';

    // Create multiple children:
    var users_child = view.child("content");
    var blog_child = view.child("blog");

    // Retrieve some rows from the database, and call back to me later
    // I will explain in more detail with the next database call
    database.query('select * from posts', function (err, rows) {
        if (err) {
            view.statusError();
        } else {
            if (rows.length) {
                blog_child.set('posts', rows);
                blog_child.render('templates/blog/many.html');
            } else {
                blog_child.render('templates/blog/empty.html');
            }
        });
    });

    // Retrieve some more rows from the database, and call back to me later.
    // Because both of the child views are handled in the callback, we have no idea which view will be rendered first. The view attached to the fastest query will be the first view to render.
    // The library handles this all for you, the order does not matter.
    database.query('select * from user', function (err, rows) {
        if (err) {
            // If an error occurred, notify the user and end the rendering immediately. This will not wait for the other database query to finish, so you can shave some time off of notifying the user.
            view.statusError();
        } else {
            if (rows.length) {
                user_child.set('users', rows);
                user_child.render('templates/user/many.html');
            } else {
                user_child.render('templates/user/empty.html');
            }
        });
    });


    // Write the view to the response
    // At this point, neither of the children will have rendered.
    // The view is flagged as "ready", and whenever the final child has rendered this view will render.
    view.render("templates/index.html");
}
</code></pre>

<h3 id="important-notes">Important notes</h3>

<ul>
<li>You must register a Renderer to any content type you wish to use.</li>
<li>The order that you render parent or child views is unimportant.</li>
<li>You must create all children before you tell the parent to render, otherwise the output template could be incomplete.</li>
</ul><h3 id="writing-your-own-renderer">Writing your own Renderer</h3>

<p>You must extend the renderer class</p>

<pre><code>var FileRenderer = module.exports = function FileRenderer() {
    Renderer.call(this);
}

util_module.inherits(FileRenderer, Renderer);
</code></pre>

<p>You must define a render function. It does not need to take any parameters, but you will be provided the proper template if possible. This template will be a string, defining the full path to the target template. If you wish to cache this file it should be handled via your renderer.</p>

<p>Each renderer will be assigned a "response" object. It may or may not be a ServerResponse object, so you can only expect expect two functions, write(mixed) and end().</p>

<p>Write should be called any time data is complete, and ready to be sent to the user. End should be called to signify the end of data.</p>

<p>Additionally each renderer will have an "_error" function. This function will be provided with the view's error handler, it should be called any time an error occurs.</p>

<pre><code>FileRenderer.prototype.render = function (template) {
    var _self = this;
    // Find the template and load it from disk
    var stream = fs_module.createReadStream(template);

    stream.on('data', function (data) {
        // Write data to the response
        _self.response.write(data);
    });

    stream.on('error', function (err) {
        // Call the renderer's error function
        _self._error(err);
    });

    stream.on('end', function () {
        // Signal the end of rendering
        _self.response.end();
    });
}
</code></pre>

<h3 id="function-reference">Function Reference</h3>

<h4 id="module-reference">Module Reference</h4>
<hr>
<h5>addRenderer(content_type, renderer)</h5>

<p>content_type : string</p>

<p>renderer : Renderer</p>

<p>Registers a renderer object to a content type.</p>

<p>Every content type used must have an associated Renderer. Included in the "renderers" folder are two examples, one for serving files directly, and one for rendering templates through Handlebars.</p>

<h5>getRenderer(content_type)</h5>

<p>content_type : string</p>

<p>Returns the appropriate renderer for the provided content_type.</p>

<p>If no renderer has been registered to the content type, an error is thrown.</p>

<h5>RENDER_STATES</h5>

<p>An object containing all of the states a bifocal object can be in.</p>

<p>RENDER_NOT_CALLED
RENDER_REQUESTED
RENDER_STARTED
RENDER_COMPLETE
RENDER_FAILED
RENDER_CANCELED</p>

<p>// todo : provide explicit definitions of each state</p>

<h5>Bifocals()</h5>

<p>Constructor for the bifocal object.
This should only be called for a root view, any child views should be spawned off the root.</p>

<p>Your first task should be to assign the response object.
Your second task should be to assign an error handler.
Be careful with the error handler though, if you request statusError to render a template, and you run into another error, you will end up in an infinite loop.</p>

<p>var view = new Bifocals();
view.response = response;
view.error(function (error) {
    console.log(error);
    view.statusError(error);
});</p>

<h4 id="bifocals-reference">Bifocals Reference</h4>
<hr>
<h5>response</h5>

<p>The object that the final rendered output will be written to.</p>

<p>Changing this will change the destination of the final rendered output.
It is not recommended to change this on child views, they use different response objects than normal. Generally only a root view would have an actual ServerResponse stored here</p>

<h5>content_type</h5>

<p>The value to put in the responses content-type header. Also used to determine which renderer should be used.</p>

<h5>template</h5>

<p>A string that is provided along with all view data to the final render step. If this string is set, it will override the template provided to the render function.</p>

<p>When provided to the renderer, it is prefixed with the <code>dir</code> property</p>

<h5>dir</h5>

<p>A string which is prefixed onto the "template" before it is send to a renderer.</p>

<p>This allows you to set a standard template directory early on, and keep it out of your render calls.</p>

<h5>parent</h5>

<p>The bifocal object that created this object.</p>

<p>Changing this to a different object will likely break the rendering hierarchy entirely.
// todo what does the parent element have here.</p>

<h5>root</h5>

<p>The original bifocal object, which started the whole series of child elements.</p>

<p>Changing this to a different object will likely break the rendering flow completely.</p>

<h5>isRendered()</h5>

<p>Returns true/false, if the view has completed its rendering process</p>

<h5>set(key, value)</h5>

<p>key : string</p>

<p>value : mixed</p>

<p>Stores a key value pair to be provided to the renderer.</p>

<p>This is useful for template engines.</p>

<h5>get(key)</h5>

<p>key : string</p>

<p>Retrieves a value that was assigned via <code>set</code>, based on the values key.</p>

<h5>canRender()</h5>

<p>Returns true/false, if the view is able to be rendered immediately.</p>

<h5>render(template, force)</h5>

<p>template : string (varies, depending on the Renderer)</p>

<p>force : optional boolean default false</p>

<p>Combines the data and template into a string, and writes it all out to the response.</p>

<p>The first parameter should be a path to your template. If you have set a dir, the template will be appended on to the dir. For the handlebars renderer, this needs to be the absolute path.</p>

<p>If you have already assigned a template to the view (via the template property), the first parameter will be ignored. The template property takes precedence over the the render functions template parameter.</p>

<p>The second parameter is a boolean. If true, all child views will be canceled and the render will happen immediately. This is generally useful for handling errors.</p>

<p>This should be the last function you manually call on a view.
If you want to use child views, they must be created before this render call, but you can keep using them after this render call.</p>

<h5>cancelRender()</h5>

<p>Stops all child views from rendering, and ensures that this view will not be rendered.</p>

<h5>buildRenderer()</h5>

<p>Builds a renderer object from various data located within this view</p>

<h5>error(fn)</h5>

<p>fn : function(error)</p>

<p>Assigns an error handler to this view. Child elements will inherit this error handler. The callback will be provided one parameter, the error.</p>

<h5>child(key, template)</h5>

<p>key : string</p>

<p>template : optional string (varies, depending on the Renderer)</p>

<p>Creates a child view, which this view will depend on.</p>

<p>The first parameter is a key. The final rendered output of the child will be set to the parent view using this key. So for example...</p>

<pre><code>var view = new Bifocals();
var child = view.child('a');
child.set('content', 'hello');

// template.html is simply {{{content}}}
child.render('template.html');

view.get('a') === 'hello';
</code></pre>

<p>The second parameter is a template. If you provide a template here, it will be considered the same as <code>child.template = template</code>. This means it will override the template provided to the <code>render</code> function call.</p>

<h5>setStatusCode(code)</h5>

<p>code : number </p>

<p>This should only be called on the parent. This sets the status code in the response headers</p>

<h5>setHeaders(headers)</h5>

<p>headers : object</p>

<p>Sets a collection of headers, where each key:value pair is a Header:value pair</p>

<h5>statusNotFound(template)</h5>

<p>template : optional string (varies, depending on the Renderer)</p>

<p>End rendering immediately with a 404: Not found status code, and renders the template if provided</p>

<h5>statusError(error, template)</h5>

<p>error : optional error</p>

<p>template : optional template (varies, depending on the Renderer)</p>

<p>End rendering immediately with a 500: Error code, and renders the template if provided
Additionally the error is assigned to the view with the key "error" </p>

<h5>statusCreated(redirect_url)</h5>

<p>redirect_url : string (url)</p>

<p>End rendering immediately with a 201: Created code. The redirect_url is provided via the Location header, and should point to the newly created resource</p>

<h5>statusRedirect(redirect_url)</h5>

<p>redirect_url : string (url)</p>

<p>End rendering immediately with a 302: Found code. The redirect_url is provided via the Location header, which the client should automatically follow.
todo: support other 300's</p>

<h5>statusNotModified()</h5>

<p>End rendering immediately with a 304: Not Modified code. This should be in response to a request with cache headers, and the client should respond by displaying the previously cached response.
//todo : as a parameter take some headers to control this? date, etag, expires, cache control</p>

<h5>statusUnsupportedMethod(supported_methods)</h5>

<p>supported_methods : array</p>

<p>Ends rendering immediately with a 405: Unsupported Method code. This should be in response to a failed request, if the request would be successful when made with an alternative http method.</p>

<h4 id="renderer-reference">Renderer Reference</h4>
<hr>
<h5>exports.Renderer = function()</h5>

<p>Constructor for the base Renderer</p>

<h5>response</h5>

<p>Automatically set when Bifocals builds a renderer. This will be an object with write(data) and end() functions.</p>

<h5>data</h5>

<p>Automatically set when Bifocals builds a renderer. This will be an object of key value pairs.</p>

<h5>error(fn)</h5>

<p>fn : function(error)</p>

<p>returns : this</p>

<p>Assigns a function that will be called any time an error occurs in the renderer. The assigned function should be called via the renderer's _error property.</p>

<h5>end(fn)</h5>

<p>returns : this</p>

<p>Assigns a function that will be called when the renderer is complete. The assigned function should be called via the _end property.</p>

<h3 id="coding-standards">Coding Standards:</h3>

<p>If a object property is prefixed with an underscore (_) IGNORE IT. Changing it is not supported, and has not been considered in the development of the library.</p>

<p>If it is not prefixed with an underscore (_) and is not a function, you can change it however you see fit. Just read the documentation and understand the side effects of changing the variable.</p>

<h3 id="future-features">Future Features:</h3>

<p>"Fill"</p>

<ul>
<li>This will be a function on the Bifocals object.</li>
<li>It will take one parameter, which will be another function.</li>
<li>The Bifocals object will keep track of the function passed via parameter, and wait to call it until the user has requested the view to be rendered.</li>
<li>The function passed via parameter should return an object. The object will be assigned as a series of key value pairs to the bifocal object via set.</li>
<li>This will make it easier to render templates from within a template, allowing all design decisions to be handled via the views.</li>
<li>This will also be more useful in error cases, or custom status codes because the function will be ignored entirely</li>
</ul>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-35124160-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
