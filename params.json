{"body":"# Bifocals\r\n==========\r\n\r\nA View library with support for asynchronous sub-views (aka partials), and interchangeable rendering systems.\r\n\r\n----\r\n\r\n### Basic Use:\r\ntemplates/index.html\r\n\r\n    <html>\r\n        <head></head>\r\n        <body>\r\n            {{{header}}}\r\n        </body>\r\n    </html>\r\n\r\ntemplates/header.html\r\n\r\n    <header>\r\n        {{title}}\r\n    </header>\r\n\r\n\r\nserver.js\r\n\r\n\t// Each content type needs to be registered to a Renderer.\r\n\t// This tells bifocals to render all text/html views via handlebars.\r\n\tbifocals_module.addRenderer('text/html', require('./renderers/handlebars_renderer'));\r\n\r\n    http_module.createServer(function (request, response) {\r\n    \t// Create the parent:\r\n        var view = new Bifocals();\r\n        view.response = response;\r\n\r\n        // Assign a content type.\r\n        view.content_type = 'text/html';\r\n\r\n        // Create the child:\r\n        var child = view.child(\"header\");\r\n        child.set('title, \"Hello World\");\r\n        child.render(\"templates/header.html\");\r\n\r\n\t\t// Write the view to the response\r\n    \tview.render(\"templates/index.html\");\r\n    }\r\n\r\nAnd you are done! When the client requests this page, it will receive the following html\r\n\r\n    <html>\r\n        <head></head>\r\n        <body>\r\n            <header>\r\n                Hello World\r\n            </header>\r\n        </body>\r\n    </html>\r\n\r\n### Why do I need this library?\r\n\r\nThe previous example does not show the benefits of the library. The benefits come when performing asynchronous actions. It might be easier to explain with a more complex example.\r\n\r\n    http_module.createServer(function (request, response) {\r\n    \t// Create the parent:\r\n        var view = new Bifocals();\r\n        view.response = response;\r\n\r\n        // Assign a content type.\r\n        view.content_type = 'text/html';\r\n\r\n        // Create multiple children:\r\n        var users_child = view.child(\"content\");\r\n        var blog_child = view.child(\"blog\");\r\n\r\n        // Retrieve some rows from the database, and call back to me later\r\n        // I will explain in more detail with the next database call\r\n        database.query('select * from posts', function (err, rows) {\r\n\t\t\tif (err) {\r\n        \t\tview.statusError();\r\n        \t} else {\r\n        \t\tif (rows.length) {\r\n        \t\t\tblog_child.set('posts', rows);\r\n        \t\t\tblog_child.render('templates/blog/many.html');\r\n        \t\t} else {\r\n        \t\t\tblog_child.render('templates/blog/empty.html');\r\n        \t\t}\r\n        \t});\r\n        });\r\n\r\n        // Retrieve some more rows from the database, and call back to me later.\r\n        // Because both of the child views are handled in the callback, we have no idea which view will be rendered first. The view attached to the fastest query will be the first view to render.\r\n        // The library handles this all for you, the order does not matter.\r\n        database.query('select * from user', function (err, rows) {\r\n        \tif (err) {\r\n        \t\t// If an error occurred, notify the user and end the rendering immediately. This will not wait for the other database query to finish, so you can shave some time off of notifying the user.\r\n        \t\tview.statusError();\r\n        \t} else {\r\n        \t\tif (rows.length) {\r\n        \t\t\tuser_child.set('users', rows);\r\n        \t\t\tuser_child.render('templates/user/many.html');\r\n        \t\t} else {\r\n        \t\t\tuser_child.render('templates/user/empty.html');\r\n        \t\t}\r\n        \t});\r\n        });\r\n        \r\n\r\n\t\t// Write the view to the response\r\n\t\t// At this point, neither of the children will have rendered.\r\n\t\t// The view is flagged as \"ready\", and whenever the final child has rendered this view will render.\r\n    \tview.render(\"templates/index.html\");\r\n    }\r\n\r\n\r\n\r\n### Important Notes\r\n* You must register a Renderer to any content type you wish to use.\r\n* The order that you render parent or child views is unimportant.\r\n* You must create all children before you tell the parent to render, otherwise the output template could be incomplete.\r\n\r\n----\r\n\r\n### Writing your own Renderer\r\n\r\nYou must extend the renderer class\r\n\r\n    var FileRenderer = module.exports = function FileRenderer() {\r\n        Renderer.call(this);\r\n    }\r\n\r\n    util_module.inherits(FileRenderer, Renderer);\r\n\r\nYou must define a render function. It does not need to take any parameters, but you will be provided the proper template if possible. This template will be a string, defining the full path to the target template. If you wish to cache this file it should be handled via your renderer.\r\n\r\nEach renderer will be assigned a \"response\" object. It may or may not be a ServerResponse object, so you can only expect expect two functions, write(mixed) and end().\r\n\r\nWrite should be called any time data is complete, and ready to be sent to the user. End should be called to signify the end of data.\r\n\r\nAdditionally each renderer will have an \"_error\" function. This function will be provided with the view's error handler, it should be called any time an error occurs.\r\n\r\n\r\n    FileRenderer.prototype.render = function (template) {\r\n\t    var _self = this;\r\n\t    // Find the template and load it from disk\r\n\t    var stream = fs_module.createReadStream(template);\r\n\r\n\t    stream.on('data', function (data) {\r\n\t    \t// Write data to the response\r\n    \t    _self.response.write(data);\r\n        });\r\n\r\n        stream.on('error', function (err) {\r\n        \t// Call the renderer's error function\r\n            _self._error(err);\r\n        });\r\n\r\n        stream.on('end', function () {\r\n        \t// Signal the end of rendering\r\n            _self.response.end();\r\n        });\r\n    }\r\n\r\n----\r\n\r\n### Function Reference\r\n\r\n---- \r\n\r\n#### Module Reference\r\n\r\n\r\n##### addRenderer(content_type, renderer)\r\ncontent_type : string\r\n\r\nrenderer : Renderer\r\n\r\nRegisters a renderer object to a content type.\r\n\r\nEvery content type used must have an associated Renderer. Included in the \"renderers\" folder are two examples, one for serving files directly, and one for rendering templates through Handlebars.\r\n\r\n\r\n##### getRenderer(content_type)\r\ncontent_type : string\r\n\r\nReturns the appropriate renderer for the provided content_type.\r\n\r\nIf no renderer has been registered to the content type, an error is thrown.\r\n\r\n\r\n##### RENDER_STATES\r\n\r\nAn object containing all of the states a bifocal object can be in.\r\n\r\nRENDER_NOT_CALLED\r\nRENDER_REQUESTED\r\nRENDER_STARTED\r\nRENDER_COMPLETE\r\nRENDER_FAILED\r\nRENDER_CANCELED\r\n\r\n// todo : provide explicit definitions of each state\r\n\r\n\r\n##### Bifocals()\r\n\r\nConstructor for the bifocal object.\r\nThis should only be called for a root view, any child views should be spawned off the root.\r\n\r\nYour first task should be to assign the response object.\r\nYour second task should be to assign an error handler.\r\nBe careful with the error handler though, if you request statusError to render a template, and you run into another error, you will end up in an infinite loop.\r\n\r\nvar view = new Bifocals();\r\nview.response = response;\r\nview.error(function (error) {\r\n\tconsole.log(error);\r\n\tview.statusError(error);\r\n});\r\n\r\n----\r\n\r\n#### Bifocals Reference\r\n\r\n\r\n##### response\r\nThe object that the final rendered output will be written to.\r\n\r\nChanging this will change the destination of the final rendered output.\r\nIt is not recommended to change this on child views, they use different response objects than normal. Generally only a root view would have an actual ServerResponse stored here\r\n\r\n##### content_type\r\nThe value to put in the responses content-type header. Also used to determine which renderer should be used.\r\n\r\n##### template\r\nA string that is provided along with all view data to the final render step. If this string is set, it will override the template provided to the render function.\r\n\r\nWhen provided to the renderer, it is prefixed with the `dir` property\r\n\r\n\r\n##### dir\r\nA string which is prefixed onto the \"template\" before it is send to a renderer.\r\n\r\nThis allows you to set a standard template directory early on, and keep it out of your render calls.\r\n\r\n\r\n##### parent\r\nThe bifocal object that created this object.\r\n\r\nChanging this to a different object will likely break the rendering hierarchy entirely.\r\n// todo what does the parent element have here.\r\n\r\n\r\n##### root\r\nThe original bifocal object, which started the whole series of child elements.\r\n\r\nChanging this to a different object will likely break the rendering flow completely.\r\n\r\n\r\n##### isRendered()\r\nReturns true/false, if the view has completed its rendering process\r\n\r\n##### set(key, value)\r\nkey : string\r\n\r\nvalue : mixed\r\n\r\nStores a key value pair to be provided to the renderer.\r\n\r\nThis is useful for template engines.\r\n\r\n\r\n##### get(key)\r\nkey : string\r\n\r\nRetrieves a value that was assigned via `set`, based on the values key.\r\n\r\n##### canRender() \r\nReturns true/false, if the view is able to be rendered immediately.\r\n\r\n##### render(template, force)\r\ntemplate : string (varies, depending on the Renderer)\r\n\r\nforce : optional boolean default false\r\n\r\nCombines the data and template into a string, and writes it all out to the response.\r\n\r\nThe first parameter should be a path to your template. If you have set a dir, the template will be appended on to the dir. For the handlebars renderer, this needs to be the absolute path.\r\n\r\nIf you have already assigned a template to the view (via the template property), the first parameter will be ignored. The template property takes precedence over the the render functions template parameter.\r\n\r\nThe second parameter is a boolean. If true, all child views will be canceled and the render will happen immediately. This is generally useful for handling errors.\r\n\r\nThis should be the last function you manually call on a view.\r\nIf you want to use child views, they must be created before this render call, but you can keep using them after this render call.\r\n\r\n##### cancelRender()\r\nStops all child views from rendering, and ensures that this view will not be rendered.\r\n\r\n##### buildRenderer()\r\nBuilds a renderer object from various data located within this view\r\n\r\n##### error(fn)\r\nfn : function(error)\r\n\r\nAssigns an error handler to this view. Child elements will inherit this error handler. The callback will be provided one parameter, the error.\r\n\r\n##### child(key, template)\r\nkey : string\r\n\r\ntemplate : optional string (varies, depending on the Renderer)\r\n\r\nCreates a child view, which this view will depend on.\r\n\r\nThe first parameter is a key. The final rendered output of the child will be set to the parent view using this key. So for example...\r\n    \r\n    var view = new Bifocals();\r\n    var child = view.child('a');\r\n    child.set('content', 'hello');\r\n    \r\n    // template.html is simply {{{content}}}\r\n    child.render('template.html');\r\n    \r\n    view.get('a') === 'hello';\r\n\r\nThe second parameter is a template. If you provide a template here, it will be considered the same as `child.template = template`. This means it will override the template provided to the `render` function call.\r\n\r\n##### setStatusCode(code)\r\ncode : number \r\n\r\nThis should only be called on the parent. This sets the status code in the response headers\r\n\r\n##### setHeaders(headers)\r\nheaders : object\r\n\r\nSets a collection of headers, where each key:value pair is a Header:value pair\r\n\r\n##### statusNotFound(template)\r\ntemplate : optional string (varies, depending on the Renderer)\r\n\r\nEnd rendering immediately with a 404: Not found status code, and renders the template if provided\r\n\r\n##### statusError(error, template)\r\nerror : optional error\r\n\r\ntemplate : optional template (varies, depending on the Renderer)\r\n\r\nEnd rendering immediately with a 500: Error code, and renders the template if provided\r\nAdditionally the error is assigned to the view with the key \"error\" \r\n\r\n##### statusCreated(redirect_url)\r\nredirect_url : string (url)\r\n\r\nEnd rendering immediately with a 201: Created code. The redirect_url is provided via the Location header, and should point to the newly created resource\r\n\r\n##### statusRedirect(redirect_url)\r\nredirect_url : string (url)\r\n\r\nEnd rendering immediately with a 302: Found code. The redirect_url is provided via the Location header, which the client should automatically follow.\r\ntodo: support other 300's\r\n\r\n\r\n##### statusNotModified()\r\n\r\nEnd rendering immediately with a 304: Not Modified code. This should be in response to a request with cache headers, and the client should respond by displaying the previously cached response.\r\n//todo : as a parameter take some headers to control this? date, etag, expires, cache control\r\n\r\n##### statusUnsupportedMethod(supported_methods)\r\nsupported_methods : array\r\n\r\nEnds rendering immediately with a 405: Unsupported Method code. This should be in response to a failed request, if the request would be successful when made with an alternative http method.\r\n\r\n\r\n----\r\n\r\n#### Renderer Reference\r\n\r\n##### exports.Renderer = function()\r\n\r\nConstructor for the base Renderer\r\n\r\n\r\n##### response\r\n\r\nAutomatically set when Bifocals builds a renderer. This will be an object with write(data) and end() functions.\r\n\r\n##### data\r\n\r\nAutomatically set when Bifocals builds a renderer. This will be an object of key value pairs.\r\n\r\n##### error(fn)\r\nfn : function(error)\r\n\r\nreturns : this\r\n\r\nAssigns a function that will be called any time an error occurs in the renderer. The assigned function should be called via the renderer's _error property.\r\n\r\n##### end(fn)\r\nreturns : this\r\n\r\nAssigns a function that will be called when the renderer is complete. The assigned function should be called via the _end property.\r\n\r\n----\r\n\r\n### Coding Standards:\r\nIf a object property is prefixed with an underscore (_) IGNORE IT. Changing it is not supported, and has not been considered in the development of the library.\r\n\r\nIf it is not prefixed with an underscore (_) and is not a function, you can change it however you see fit. Just read the documentation and understand the side effects of changing the variable.\r\n\r\n### Future Features:\r\n\r\n\"Fill\"\r\n\r\n- This will be a function on the Bifocals object.\r\n- It will take one parameter, which will be another function.\r\n- The Bifocals object will keep track of the function passed via parameter, and wait to call it until the user has requested the view to be rendered.\r\n- The function passed via parameter should return an object. The object will be assigned as a series of key value pairs to the bifocal object via set.\r\n- This will make it easier to render templates from within a template, allowing all design decisions to be handled via the views.\r\n- This will also be more useful in error cases, or custom status codes because the function will be ignored entirely\r\n","tagline":"The view component of the roads framework","name":"Bifocals","note":"Don't delete this file! It's used internally to help with page regeneration.","google":"UA-35124160-1"}